<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>k-means: &lt;i&gt;k&lt;/i&gt;-means clustering</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">k-means
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title"><em>k</em>-means clustering </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><b>Overview and notes on use</b></h2>
<p>This collection of templates implements <em>k</em>-means clustering.</p>
<p>This implementation of k-means employs the following strategy:</p><ol type="1">
<li>Pick a population member at random, assign its value as the centroid of cluster 0.</li>
<li>For clusters 1 through k-1: select the member of the population that is <em>farthest</em> from all clusters whose centroids have already been assigned (where farthest is the maximum of the sum of euclidean distances from the candidate population element to each of the centroids).</li>
<li>Assign each element of the population to the nearest cluster, where <em>nearest</em> corresponds to minimum euclidean distance.</li>
<li>Recalculate the centroids of all clusters, such that the centroid is the mean of all of its member vectors.</li>
<li>Repeat steps 3 and 4 until the cluster memberships are stable, that is, two consecutive iterations result in the same cluster memberships.</li>
</ol>
<p>A simple use case includes these steps:</p>
<ol type="1">
<li>Define the problem space, typically by instantiating the <a class="el" href="classutils_1_1k__means.html" title="A class template that partitions a data set into clusters using k-means. ">k_means</a> class template</li>
<li>Prepare input data</li>
<li>Construct an instance of (previously instantiated) <a class="el" href="classutils_1_1k__means.html" title="A class template that partitions a data set into clusters using k-means. ">k_means</a> template class, passing it the input data</li>
<li>Obtain the resulting <a class="el" href="classutils_1_1cluster.html">cluster </a> objects from the <a class="el" href="classutils_1_1k__means.html" title="A class template that partitions a data set into clusters using k-means. ">k_means</a></li>
</ol>
<h3><b>Define the problem space</b></h3>
<p>The problem space is defined by the <em>dimensional</em> <em>cardinality</em> of the space, and the underlying scalar type (e.g., <code>double</code>) used to represent vector components. These correspond (in reverse order) to the template parameters for k_means&lt;T,N&gt;. For example, to define a 2-dimensional space with scalar elements of type <code>double:</code> </p><div class="fragment"><div class="line"><span class="keyword">using</span> km_type = <a class="code" href="classutils_1_1k__means.html">utils::k_means&lt;double, 2&gt;</a>;</div></div><!-- fragment --><p> or, if you prefer: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classutils_1_1k__means.html">utils::k_means&lt;double, 2&gt;</a> km_type;</div></div><!-- fragment --><p>This alias (or <code>typedef</code>) makes it easer to define instances of related types, using aliases defined in the <code><a class="el" href="classutils_1_1k__means.html" title="A class template that partitions a data set into clusters using k-means. ">k_means</a></code> template, to wit:</p><ul>
<li><code>km_type::vector_type</code> : the type of a vector in the problem space, i.e., the type of input data</li>
<li><code>km_type::scalar_type</code> : the underlying aritnmetic type of vector components (T template parameter)</li>
<li><code>km_type::population_type</code> : the type of the container for input data</li>
<li><code>km_type::cluster_type</code> : the type of clusters generated by the k-means algorithm, i.e., an element of the output</li>
<li><code>km_type::cluster_container_type</code> : the type of the container of clusters</li>
</ul>
<p>Note that the alias declaration does not, in itself, instantiate the class template. If you use one of the types above in a definition, for example: </p><div class="fragment"><div class="line">km_type::population_type data = { ... };</div></div><!-- fragment --><p> then the class template will be instantiated.</p>
<h3><b>Input data</b></h3>
<h4><b>Vector type</b></h4>
<p>Given the previous definition of <code>km_type</code>, the alias <code>km_type::vector_type</code> corresponds to <code>utils::euclidean_vector&lt;double,2&gt;</code>. The <code><a class="el" href="classutils_1_1euclidean__vector.html" title="A vector in the problem space. ">euclidean_vector</a></code> class template is used to represent any N-dimensional value (where N &gt; 1) in the problem space, including input data and cluster centroids. The template is derived publicly from <code>std:array</code>, inheriting its interface. For the most part, programs using k-means will use instances of <a class="el" href="classutils_1_1euclidean__vector.html" title="A vector in the problem space. ">euclidean_vector</a> just as if they were instances of std::array&mdash;they can be constructed with initializer lists: </p><div class="fragment"><div class="line">km_type::vector_type v{1.43, 0.95};</div></div><!-- fragment --><p> Individual components can be accessed or set with the subscript operator: </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> x = v[0];</div><div class="line">v[1] = x * x;</div></div><!-- fragment --><h4><b>Specialization for N=1</b></h4>
<p>If the problem space is one-dimensional, partial template specializations redefine the component types of cluster and <a class="el" href="classutils_1_1k__means.html" title="A class template that partitions a data set into clusters using k-means. ">k_means</a> to avoid using the <a class="el" href="classutils_1_1euclidean__vector.html" title="A vector in the problem space. ">euclidean_vector</a> template for data values. Essentially, everywhere <a class="el" href="classutils_1_1euclidean__vector.html">euclidean_vector&lt;T,N&gt; </a> is used as a parameter, return type, or component type when N &gt; 1, it is replaced by the scalar type T when N = 1. For example:</p>
<ul>
<li><code>vector_type</code> is aliased to <code>T</code>, the scalar type</li>
<li><code>population_type</code> is aliased to <code>std::vector&lt;T&gt;</code> </li>
<li><code><a class="el" href="classutils_1_1cluster.html#a281be3efc20eb98ee8cb93aeb527577f" title="Returns the centroid of the cluster. ">cluster::centroid()</a></code> returns a value of type T</li>
</ul>
<p>and so on.</p>
<h4><b>Input container</b></h4>
<p>The type <code>population_type</code> is an alias for <code>std::vector&lt;km_type::vector_type&gt;</code>, that is, a container of input data. The population vector can be inialized in any number of ways, including the use of an initializer list: </p><div class="fragment"><div class="line">km_type::population_type input =</div><div class="line">{</div><div class="line">    {0.0, 0.0},</div><div class="line">    {0.2, -0.1},</div><div class="line">    {1.0, 1.0},</div><div class="line">    {1.2, 0.8},</div><div class="line">    {-1.0, -1.0},</div><div class="line">    {-1.1, -0.9}</div><div class="line">};</div></div><!-- fragment --><h4><b>Population member identity</b></h4>
<p>Each member of the input population is implicitly identified by its index in the population vector. The programmer is responsible for maintaining an association between the application objects being clustered and their corresponding vectors in the population. In particular, the output clusters describe their contents (that is, which data are members of the cluster) in terms of the members' indices in the population vector.</p>
<h3><b>Construct the <a class="el" href="classutils_1_1k__means.html" title="A class template that partitions a data set into clusters using k-means. ">k_means</a> instance</b></h3>
<p>The <a class="el" href="classutils_1_1k__means.html#a90ff4d8440c8a57b0411c929da285621">constructor </a> of <a class="el" href="classutils_1_1k__means.html" title="A class template that partitions a data set into clusters using k-means. ">k_means</a> takes two parameters: </p><div class="fragment"><div class="line">k_means(<span class="keyword">const</span> population_type &amp;population, std::size_t k)</div></div><!-- fragment --><p> The first, <code>population</code>, is the input data set. The second, <code>k</code>, is the number of clusters into which the population will be partitioned.</p>
<p>Given the previous definitions of <code>km_type</code>, and the population vector <code>input</code>, we can construct the result set: </p><div class="fragment"><div class="line">km_type km(input, 3);</div></div><!-- fragment --><h4><b>Determining a value for <em>k</em> </b></h4>
<p>A value of <em>k</em> (the number of clusters into which the population is partitioned) must be specified. In most cases, an optimal value for <em>k</em> is not known <em>a</em> <em>priori</em>. Strategies for determining a reasonable value for <em>k</em> are beyond the scope of this discussion, but many such strategies are available from internet sources. Many strategies use the sum of squared errors of the population as an objective function. This value is returned by <code><a class="el" href="classutils_1_1k__means.html#a4d37887c69abf52f82003c086d2e8029" title="Returns the sum of squared errors of the population. ">k_means::sse()</a></code>.</p>
<h3><b>Get the resulting clusters</b></h3>
<p>The method <a class="el" href="classutils_1_1k__means.html#a64cf294cfddb00b7863d210cdbc560a0" title="Returns a container of cluster objects resulting from k-means partitioning of the population...">k_means::clusters()</a> returns a reference to the vector containing the resulting cluster objects. When iterating over this vector, don't assume that the size of the vector is equal to k (specified in the constructor). In some circumstances, the actual number of resulting clusters may be fewer than k. From each cluster, you can get information about the cluster, such as the centroid and the standard deviation. The method <a class="el" href="classutils_1_1cluster.html#a8aabc5a412a8940ee2b8af28ac21c80d" title="Returns a set describing cluster membership. ">cluster::members()</a> returns a container of type <code>std::set&lt;std::size_t&gt;</code>. This set contains the indices in the population vector of elements that belong to the cluster: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0; i &lt; km.clusters().size(); ++i)</div><div class="line">{</div><div class="line">    <span class="keyword">auto</span>&amp; cluster = km.clusters()[i];</div><div class="line">    </div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;cluster &quot;</span> &lt;&lt; i;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; - centroid: &quot;</span> &lt;&lt; cluster.centroid();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;, sigma: &quot;</span> &lt;&lt; cluster.sigma();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;, members: &quot;</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = cluster.members().cbegin(); it != cluster.members().cend(); ++it)</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;population[&quot;</span> &lt;&lt; *it &lt;&lt; <span class="stringliteral">&quot;] : &quot;</span> &lt;&lt; input[*it] &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> Note that <a class="el" href="classutils_1_1euclidean__vector.html" title="A vector in the problem space. ">euclidean_vector</a> provides an <a class="el" href="classutils_1_1euclidean__vector.html#a151c57500ff052e321798733ad27e797">operator&lt;&lt; </a> for output streams, which prints the values in the vector enclosed in braces {}, separated by commas. The output of this loop should look like this (the cluster order may vary): </p><div class="fragment"><div class="line">cluster 0 - centroid: { 1.1, 0.9 }, sigma: 0.141421, members:</div><div class="line">population[2] : { 1, 1 }</div><div class="line">population[3] : { 1.2, 0.8 }</div><div class="line">cluster 1 - centroid: { -1.05, -0.95 }, sigma: 0.0707107, members: </div><div class="line">population[4] : { -1, -1 }</div><div class="line">population[5] : { -1.1, -0.9 }</div><div class="line">cluster 2 - centroid: { 0.1, -0.05 }, sigma: 0.111803, members: </div><div class="line">population[0] : { 0, 0 }</div><div class="line">population[1] : { 0.2, -0.1 }</div></div><!-- fragment --><p>Alternatively, you can get a single <em>result vector</em> from the <a class="el" href="classutils_1_1k__means.html" title="A class template that partitions a data set into clusters using k-means. ">k_means</a> instance: </p><div class="fragment"><div class="line"><span class="keyword">auto</span>&amp; results = km.result_vector();</div></div><!-- fragment --><p> This type of this vector is <code>std::vector&lt;std::size_t&gt;</code>. It is, essentially, a map from population element indices to cluster indices&mdash;the i<sup>th</sup> element of the result vector contains the index of the cluster (in the vector returned by <a class="el" href="classutils_1_1k__means.html#a64cf294cfddb00b7863d210cdbc560a0" title="Returns a container of cluster objects resulting from k-means partitioning of the population...">k_means::clusters()</a>) to which the i<sup>th</sup> element of the population vector belongs: </p><div class="fragment"><div class="line"><span class="keyword">auto</span>&amp; result_vec = km.result_vector();</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0; i &lt; result_vec.size(); ++i)</div><div class="line">{</div><div class="line">    <span class="keyword">auto</span> icluster = result_vec[i];</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;input element &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; input[i] &lt;&lt; <span class="stringliteral">&quot; is a member of cluster &quot;</span> &lt;&lt; icluster &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>The output of this loop should look like this (again, cluster indices/order may vary): </p><div class="fragment"><div class="line">input element 0 { 0, 0 } is a member of cluster 2</div><div class="line">input element 1 { 0.2, -0.1 } is a member of cluster 2</div><div class="line">input element 2 { 1, 1 } is a member of cluster 0</div><div class="line">input element 3 { 1.2, 0.8 } is a member of cluster 0</div><div class="line">input element 4 { -1, -1 } is a member of cluster 1</div><div class="line">input element 5 { -1.1, -0.9 } is a member of cluster 1</div></div><!-- fragment --><dl class="section author"><dt>Author</dt><dd>David Curtis </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
