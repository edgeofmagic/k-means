/*
MIT License

Copyright Â© 2016 David Curtis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#ifndef guard_utils_k_means_h
#define guard_utils_k_means_h

#include <unordered_set>
#include <vector>
#include <set>
#include <algorithm>
#include <random>
#include <assert.h>
#include <sstream>
#include <array>

#define TRACE 0

namespace utils
{

	/*! \mainpage <i>k</i>-means clustering
	
		<h2><b>Overview and notes on use</b></h2>
		
		This collection of templates implements <i>k</i>-means clustering. 
	 
		This implementation of k-means employs the following strategy:
		1. Pick a population member at random, assign its value as the centroid of cluster 0.
		2. For clusters 1 through k-1: select the member of the population that is \a farthest from all
		clusters whose centroids have already been assigned (where farthest is the maximum of the sum of
		euclidean distances from the candidate population element to each of the centroids).
		3. Assign each element of the population to the nearest cluster, where \a nearest corresponds to minimum
		euclidean distance.
		4. Recalculate the centroids of all clusters, such that the centroid is the mean of all of its member vectors.
		5. Repeat steps 3 and 4 until the cluster memberships are stable, that is, two consecutive iterations result
		in the same cluster memberships.
	 
		A simple use case
		includes these steps:
		
		1. Define the problem space, typically by instantiating the k_means class template
		2. Prepare input data
		3. Construct an instance of (previously instantiated) k_means template class, passing it the input data
		4. Obtain the resulting \link cluster cluster \endlink objects from the k_means

		<h3><b>Define the problem space</b></h3>
		
		The problem space is defined by the \a dimensional \a cardinality of the space, and the underlying scalar type (e.g., \c double)
		used to represent vector components. These correspond (in reverse order) to the template parameters for k_means<T,N>. 
		For example, to define a 2-dimensional space with scalar elements of type \c double:
		\code{.cpp}
			using km_type = utils::k_means<double, 2>;
		\endcode
		or, if you prefer:
		\code{.cpp}
			typedef utils::k_means<double, 2> km_type;
		\endcode
		
		This alias (or \c typedef) makes it easer to define instances of related types, using aliases
		defined in the \c k_means template, to wit:
		+ \c km_type::vector_type : the type of a vector in the problem space, i.e., the type of input data
		+ \c km_type::scalar_type : the underlying aritnmetic type of vector components (T template parameter)
		+ \c km_type::population_type : the type of the container for input data
		+ \c km_type::cluster_type : the type of clusters generated by the k-means algorithm, i.e., an element of the output
		+ \c km_type::cluster_container_type : the type of the container of clusters

		Note that the alias declaration does not, in itself, instantiate the class template. If you use one
		of the types above in a definition, for example:
		\code
		km_type::population_type data = { ... };
		\endcode
		then the class template will be instantiated.
		
		<h3><b>Input data</b></h3>
		
		<h4><b>Vector type</b></h4>
		
		Given the previous definition of \c km_type, the alias \c km_type::vector_type
		corresponds to \c utils::euclidean_vector<double,2>. The \c euclidean_vector class template is used to represent
		any N-dimensional value (where N > 1) in the problem space, including input data and cluster centroids.
		The template is derived publicly from \c std:array, inheriting its interface. For the most part, programs 
		using k-means will use instances of euclidean_vector just as if they were instances of std::array---they 
		can be constructed with initializer lists:
		\code
			km_type::vector_type v{1.43, 0.95};
		\endcode
		Individual components can be accessed or set with the subscript operator:
		\code
			double x = v[0];
			v[1] = x * x;
		\endcode

		<h4><b>Specialization for N=1</b></h4>

		If the problem space is one-dimensional, partial template specializations redefine the component types of 
		cluster and k_means to avoid using the euclidean_vector template for data values. Essentially, 
		everywhere \link euclidean_vector euclidean_vector<T,N> \endlink is used as a parameter, return type, or component type when N > 1,
		it is replaced by the scalar type T when N = 1. For example:
		
		+ \c vector_type is aliased to \c T, the scalar type
		+ \c population_type is aliased to \c std::vector<T>
		+ \c cluster::centroid() returns a value of type T
		
		and so on.
		
		<h4><b>Input container</b></h4>
		
		The type \c population_type
		is an alias for \c std::vector<km_type::vector_type>, that is, a container of input data. The population
		vector can be inialized in any number of ways, including the use of an initializer list:
		\code
		km_type::population_type input =
		{
			{0.0, 0.0},
			{0.2, -0.1},
			{1.0, 1.0},
			{1.2, 0.8},
			{-1.0, -1.0},
			{-1.1, -0.9}
		};
		\endcode
		
		<h4><b>Population member identity</b></h4>
		
		Each member of the input population is implicitly identified by its index in the population vector. The programmer
		is responsible for maintaining an association between the application objects being clustered and their corresponding
		vectors in the population. In particular, the output clusters describe their contents (that is, which 
		data are members of the cluster) in terms of the members' indices in the population vector.
		
		<h3><b>Construct the k_means instance</b></h3>

		The \link k_means::k_means constructor \endlink of
		k_means takes two parameters:
		\code
		k_means(const population_type &population, std::size_t k)
		\endcode
		The first, \c population, is the input data set. The second, \c k, is the number
		of clusters into which the population will be partitioned.
		
		Given the previous definitions of \c km_type, and the population vector \c input, we can construct
		the result set:
		\code
			km_type km(input, 3);
		\endcode
		
		<h4><b>Determining a value for \a k </b></h4>
		
		A value of \a k (the number of clusters into which the population is partitioned) must be specified.
		In most cases, an optimal value for \a k is not known \a a \a priori. Strategies for determining a
		reasonable value for \a k  are beyond the scope of this discussion, but many such strategies are
		available from internet sources. Many strategies use the sum of squared errors of the population
		as an objective function. This value is returned by \c k_means::sse().
		
		
		<h3><b>Get the resulting clusters</b></h3>

		The method k_means::clusters() returns a reference to the vector containing the resulting cluster objects.
		When iterating over this vector, don't assume that the size of the vector is equal to k (specified in the constructor).
		In some circumstances, the actual number of resulting clusters may be fewer than k. From each cluster, you can get
		information about the cluster, such as the centroid and the standard deviation. 
		The method cluster::members() returns a container of type \c std::set<std::size_t>.
		This set contains the indices in the population vector of elements that belong to the cluster:
		\code
		for (auto i = 0; i < km.clusters().size(); ++i)
		{
			auto& cluster = km.clusters()[i];
			
			std::cout << "cluster " << i;
			std::cout << " - centroid: " << cluster.centroid();
			std::cout << ", sigma: " << cluster.sigma();
			std::cout << ", members: " << std::endl;
			for (auto it = cluster.members().cbegin(); it != cluster.members().cend(); ++it)
			{
				std::cout << "population[" << *it << "] : " << input[*it] << std::endl;
			}
		}
		\endcode
		Note that euclidean_vector provides an \link euclidean_vector::operator<<() operator<< \endlink for output streams,
		which prints the values in the vector enclosed in braces {}, separated by commas. The output 
		of this loop should look like this (the cluster order may vary):
		\code
		cluster 0 - centroid: { 1.1, 0.9 }, sigma: 0.141421, members:
		population[2] : { 1, 1 }
		population[3] : { 1.2, 0.8 }
		cluster 1 - centroid: { -1.05, -0.95 }, sigma: 0.0707107, members: 
		population[4] : { -1, -1 }
		population[5] : { -1.1, -0.9 }
		cluster 2 - centroid: { 0.1, -0.05 }, sigma: 0.111803, members: 
		population[0] : { 0, 0 }
		population[1] : { 0.2, -0.1 }
		\endcode
		
		Alternatively, you can get a single <i>result vector</i> from the k_means instance:
		\code
		auto& results = km.result_vector();
		\endcode
		This type of this vector is \c std::vector<std::size_t>. It is, essentially, a map from population element indices
		to cluster indices---the i<sup>th</sup> element of the result vector contains the index of the cluster (in the vector
		returned by k_means::clusters()) to which the i<sup>th</sup> element of the population vector belongs:
		\code
		auto& result_vec = km.result_vector();
		for (auto i = 0; i < result_vec.size(); ++i)
		{
			auto icluster = result_vec[i];
			std::cout << "input element " << i << " " << input[i] << " is a member of cluster " << icluster << std::endl;
		}
		\endcode
		
		The output of this loop should look like this (again, cluster indices/order may vary):
		\code
		input element 0 { 0, 0 } is a member of cluster 2
		input element 1 { 0.2, -0.1 } is a member of cluster 2
		input element 2 { 1, 1 } is a member of cluster 0
		input element 3 { 1.2, 0.8 } is a member of cluster 0
		input element 4 { -1, -1 } is a member of cluster 1
		input element 5 { -1.1, -0.9 } is a member of cluster 1
		\endcode
	 
		\author David Curtis
	 
	*/

	template <class T, std::size_t N>
	class k_means;

	/*! \class euclidean_vector
		\brief A vector in the problem space.
		\tparam T The scalar type of vector components. \c std::is_arithmetic<T>::value must be \c true.
		\tparam N The size of a vector, corresponding to the dimensional cardinality of the problem space.
		N must be greater than one.
	
		\c \b euclidean_vector represents a vector in the problem space (that is, the space within which clusters are partitioned).
		An instance of \c euclidean_vector may represent a data point, an abstract point (such as a cluster centroid), 
		or a sum (or difference) of vectors. \c euclidean_vector derives from \c std:array, inheriting
		its public interface. If the dimensional cardinality of a k_means instance is 1, this class will not be used 
		to represent values in the problem space; they will be scalar values.
		
		\author David Curtis
	*/
	template<class T, std::size_t N>
	class euclidean_vector : public std::array<T, N>
	{
	public:

		static_assert(std::is_arithmetic<T>(), "first template parameter must be an arithemetic type");
		static_assert(N > 1, "second template parameter must be greater than one");
		
		using base = std::array<T, N>;
		using scalar_type = T;
		static constexpr std::size_t size = N;
		
		/*! \brief Constructor from \c std::vector<T>.
			\param vec A container of type \c std::vector<T> containing values to be copied into the constructed vector.

			Values in vec are copied into the constructed euclidean_vector, in
			their respective positions. If the size of \c vec is greater than N, only
			values 0 .. N-1 are copied. If the size of \c vec is less than N, the
			remaining components of the constructed vector are set to zero.
			
			\author David Curtis
		*/
		euclidean_vector(const std::vector<T>& vec)
		:
		base{static_cast<T>(0)}
		{
			for (std::size_t i = 0; i < vec.size() && i < N; ++i)
			{
				(*this)[i] = vec[i];
			}
		}
		
		/*! \brief Constructor from \c std::initializer_list<T>.
			\param list An initializer list containing values to be copied into the constructed vector.

			Values in list are copied into the constructed euclidean_vector, in
			their respective positions. If the size of list is greater than N, only
			values 0 .. N-1 are copied. If the size of list is less than N, the
			remaining components of the constructed vector are set to zero.
			
			\author David Curtis
		*/
		euclidean_vector(std::initializer_list<T> list)
		{
			std::size_t i = 0;
			for (auto it = list.begin(); it != list.end(); ++it)
			{
				(*this)[i] = *it;
				++i;
			}
		}
		
		/*! \brief Copy constructor.
			\param rhs The source of values to be copied into the constructed vector.
			
			\author David Curtis
		*/
		euclidean_vector(const euclidean_vector& rhs)
		:
		base{rhs}
		{}

		/*! \brief Move constructor.
			\param rhs The source of values to be moved into the constructed vector.
			
			\author David Curtis
		*/
		euclidean_vector(euclidean_vector&& rhs)
		:
		base{std::move(rhs)}
		{}
		
		/*! \brief Null constructor.
			
			Elements of the constructed vector are set to zero.
			
			\author David Curtis
		*/
		euclidean_vector()
		:
		base{static_cast<T>(0)}
		{}
		
		/*! \brief Scalar-initialized constructor.
			\param value A scalar value (type T) assigned to all elements of the constructed vector.
			
			The value parameter is statically cast to type T, and assigned to 
			all elements of the constructed vector.
			
			\author David Curtis
		*/
		template<class U>
		euclidean_vector(U value)
		{
			static_assert(std::is_arithmetic<U>(), "parameter must be an arithemetic type");

			for (std::size_t i = 0; i < N; ++i)
			{
				(*this)[i] = static_cast<scalar_type>(value);
			}
		}
		
		/*! \brief Copy assignment operator.
			\param rhs The source of values to be copied into this vector.
		 
			\author David Curtis
		*/
		euclidean_vector&
		operator=(const euclidean_vector& rhs)
		{
			for (std::size_t i = 0; i < N; ++i)
			{
				(*this)[i] = rhs[i];
			}
			return *this;
		}
		
		/*! \brief Scalar value assignment operator.
			\param value A scalar value to be assigned to all elements of this vector.
			
			The value parameter is statically cast to type T and assigned
			to all elements of this vector.
		 
			\author David Curtis
		*/
		template<class U>
		euclidean_vector& operator=(U value)
		{
			static_assert(std::is_arithmetic<U>(), "parameter must be an arithemetic type");

			for (std::size_t i = 0; i < N; ++i)
			{
				(*this)[i] = static_cast<scalar_type>(value);
			}
			return *this;
		}
		
		/*! \brief Compound assignment/subtraction operator.
			\param x A vector to be subtracted from this vector.
			\return A reference to this vector.
		 
			 Where this vector \f$ \mathbf{v} \f$ has N elements:
			
			\f$ \mathbf{ v } = [ \mathit{v_1} \hspace{3mm} \mathit{v_2 } \hspace{3mm} \cdots \hspace{3mm} \mathit{v_{N-1}} \hspace{3mm} \mathit{v_N} ] \f$
			
			and \f$ \mathbf{x} \f$:
		 
			\f$ \mathbf{ x } = [ \mathit{x_1} \hspace{3mm} \mathit{x_2 } \hspace{3mm} \cdots \hspace{3mm} \mathit{x_{N-1}} \hspace{3mm} \mathit{x_N} ] \f$
			
			then this vector \f$ \mathbf{v} \f$ is modified:

			\f$ \mathbf{ v' } = [ \mathit{v_1-x_1} \hspace{3mm} \mathit{v_2-x_2 } \hspace{3mm} \cdots \hspace{3mm} \mathit{v_{N-1}-x_{N-1}} \hspace{3mm} \mathit{v_N-x_N} ] \f$
		 
			\author David Curtis
		*/
		inline euclidean_vector&
		operator-=(const euclidean_vector& x)
		{
			for (std::size_t i = 0; i < N; ++i)
			{
				(*this)[i] -= x[i];
			}
			return *this;
		}
	
		/*! \brief Compound assignment/addition operator.
			\param x A vector to be added to this vector.
			\return A reference to this vector.
		 
			 Where this vector \f$ \mathbf{v} \f$ has N elements:
			
			\f$ \mathbf{ v } = [ \mathit{v_1} \hspace{3mm} \mathit{v_2 } \hspace{3mm} \cdots \hspace{3mm} \mathit{v_{N-1}} \hspace{3mm} \mathit{v_N} ] \f$
			
			and \f$ \mathbf{x} \f$:
		 
			\f$ \mathbf{ x } = [ \mathit{x_1} \hspace{3mm} \mathit{x_2 } \hspace{3mm} \cdots \hspace{3mm} \mathit{x_{N-1}} \hspace{3mm} \mathit{x_N} ] \f$
			
			then \f$ \mathbf{v} \f$ is modified:

			\f$ \mathbf{ v' } = [ \mathit{v_1+x_1} \hspace{3mm} \mathit{v_2+x_2 } \hspace{3mm} \cdots \hspace{3mm} \mathit{v_{N-1}+x_{N-1}} \hspace{3mm} \mathit{v_N+x_N} ] \f$
		 
			\author David Curtis
		*/
		inline euclidean_vector&
		operator+=(const euclidean_vector& x)
		{
			for (std::size_t i = 0; i < N; ++i)
			{
				(*this)[i] += x[i];
			}
			return *this;
		}
		
		/*! \brief Compound assignment/scalar multiplication operator.
			\param x A scalar multiplier for elements of this vector.
			\return A reference to this vector.
		 
			Multiplies this vector by the scalar parameter.
			
			Where this vector \f$ \mathbf{v} \f$ has N elements:
			
			\f$ \mathbf{ v } = [ \mathit{v_1} \hspace{3mm} \mathit{v_2 } \hspace{3mm} \cdots \hspace{3mm} \mathit{v_{N-1}} \hspace{3mm} \mathit{v_N} ] \f$
			
			then this vector \f$ \mathbf{v} \f$ is modified:

			\f$ \mathbf{ v' } = [ \mathit{v_1*x} \hspace{3mm} \mathit{v_2*x} \hspace{3mm} \cdots \hspace{3mm} \mathit{v_{N-1}*x} \hspace{3mm} \mathit{v_N*x} ] \f$
		 
			\author David Curtis
		*/
		inline euclidean_vector&
		operator*=(T x)
		{
			for (std::size_t i = 0; i < N; ++i)
			{
				(*this)[i] += x;
			}
			return *this;
		}
	
		/*! \brief compound assignment/scalar division operator.
			\param x A scalar divisor for the elements of this vector.
			\return A reference to this vector.
		 
			Divides this vector by the parameter \c x (technically, it multiplies by the 1/x, since scalar division
			of vectors isn't a thing).
			
			Where this vector \f$ \mathbf{v} \f$ has N elements:
			
			\f$ \mathbf{ v } = [ \mathit{v_1} \hspace{3mm} \mathit{v_2 } \hspace{3mm} \cdots \hspace{3mm} \mathit{v_{N-1}} \hspace{3mm} \mathit{v_N} ] \f$
			
			then this vector \f$ \mathbf{v} \f$ is modified:

			\f$ \mathbf{ v' } = [ \mathit{v_1/x} \hspace{3mm} \mathit{v_2/x} \hspace{3mm} \cdots \hspace{3mm} \mathit{v_{N-1}/x} \hspace{3mm} \mathit{v_N/x} ] \f$
		 
			\author David Curtis
		*/
		inline euclidean_vector&
		operator/=(T x)
		{
			for (std::size_t i = 0; i < N; ++i)
			{
				(*this)[i] /= x;
			}
			return *this;
		}
		
		/*! \brief Binary vector subtraction operator.
			\param x A vector to be subtracted from this vector.
			\return A vector containing the difference between this vector and x (this - x).
		 
			 Where this vector \f$ \mathbf{v} \f$ has N elements:
			
			\f$ \mathbf{ v } = [ \mathit{v_1} \hspace{3mm} \mathit{v_2 } \hspace{3mm} \cdots \hspace{3mm} \mathit{v_{N-1}} \hspace{3mm} \mathit{v_N} ] \f$
			
			and \f$ \mathbf{x} \f$:
		 
			\f$ \mathbf{ x } = [ \mathit{x_1} \hspace{3mm} \mathit{x_2 } \hspace{3mm} \cdots \hspace{3mm} \mathit{x_{N-1}} \hspace{3mm} \mathit{x_N} ] \f$
			
			then the result \f$ \mathbf{r} \f$ contains:

			\f$ \mathbf{r} = [ \mathit{v_1-x_1} \hspace{3mm} \mathit{v_2-x_2 } \hspace{3mm} \cdots \hspace{3mm} \mathit{v_{N-1}-x_{N-1}} \hspace{3mm} \mathit{v_N-x_N} ] \f$
		 
			\author David Curtis
		*/
		inline euclidean_vector
		operator-(const euclidean_vector& x) const
		{
			euclidean_vector result(*this);
			result -= x;
			return result;
		}
		
		/*! \brief Binary vector addition operator.
			\param x A vector to be summed with this vector
			\return a A vector containing the sum of this vector and x.
		 
			 Where this vector \f$ \mathbf{v} \f$ has N elements:
			
			\f$ \mathbf{ v } = [ \mathit{v_1} \hspace{3mm} \mathit{v_2 } \hspace{3mm} \cdots \hspace{3mm} \mathit{v_{N-1}} \hspace{3mm} \mathit{v_N} ] \f$
			
			and \f$ \mathbf{x} \f$:
		 
			\f$ \mathbf{ x } = [ \mathit{x_1} \hspace{3mm} \mathit{x_2 } \hspace{3mm} \cdots \hspace{3mm} \mathit{x_{N-1}} \hspace{3mm} \mathit{x_N} ] \f$
			
			then the result \f$ \mathbf{r} \f$ contains:

			\f$ \mathbf{r} = [ \mathit{v_1+x_1} \hspace{3mm} \mathit{v_2+x_2 } \hspace{3mm} \cdots \hspace{3mm} \mathit{v_{N-1}+x_{N-1}} \hspace{3mm} \mathit{v_N+x_N} ] \f$
		 
			\author David Curtis
		*/
		inline euclidean_vector
		operator+(const euclidean_vector& x) const
		{
			euclidean_vector result(*this);
			result += x;
			return result;
		}
		
		/*! \brief Stream output operator.
			\param os An output stream on which a representation of \c vec will be printed.
			\param vec A vector whose representation is printed on the stream \c os
			\return A reference to \c os.

			This operator prints the elements of this vector in ascending index order, enclosed in braces '{}' and
			separated by commas.
		 
			\author David Curtis
		*/
		friend std::ostream&
		operator<<(std::ostream& os, const euclidean_vector<T, N>& vec)
		{
			os << "{ ";
			for (std::size_t i = 0; i < N; ++i)
			{
				os << vec[i];
				if (i < N - 1)
				{
					os << ", ";
				}
			}
			os << " }";
			return os;
		}
	};
	
	/*
		The following vector_traits structs and function templates euclidean_distance and magnitude
		make it possible for the implementations of cluster and k_means to operate on either
		euclidean_vector values or scalar values, with the same code.
	 */
	
	template<class T, std::size_t N>
	struct vector_traits
	{
		static_assert(std::is_arithmetic<T>(), "first template parameter must be an arithemetic type");
		using scalar_type = T;
		using type = euclidean_vector<T, N>;
		using param_type = const euclidean_vector<T, N>&;
		using return_type = type;
		static constexpr std::size_t cardinality = N;
	};
	
	template<class T>
	struct vector_traits<T, 1>
	{
		static_assert(std::is_arithmetic<T>(), "template parameter must be an arithemetic type");
		using scalar_type = T;
		using type = T;
		using param_type = type;
		using return_type = type;
		static constexpr std::size_t cardinality = 1;
	};

	template<class T, std::size_t N>
	struct euclidean_distance
	{
		static_assert(std::is_arithmetic<T>(), "first template parameter must be an arithemetic type");
		
		using vtraits = vector_traits<T, N>;
		
		typename vtraits::scalar_type
		operator()(typename vtraits::param_type a, typename vtraits::param_type  b)
		{
			typename vtraits::scalar_type sum = static_cast<typename vtraits::scalar_type>(0);
			for (std::size_t i = 0; i < vtraits::cardinality; ++i)
			{
				typename vtraits::scalar_type diff = b[i] - a[i];
				sum += diff * diff;
			}
			return static_cast<typename vtraits::scalar_type>( sqrt( static_cast<long double>(sum)));
		}
	};
	
	template<class T>
	struct euclidean_distance<T, 1>
	{
		static_assert(std::is_arithmetic<T>(), "template parameter must be an arithemetic type");

		using vtraits = vector_traits<T, 1>;
		
		typename vtraits::return_type
		operator()(typename vtraits::param_type a, typename vtraits::param_type  b)
		{
			return std::abs(b - a);
		};
	};

	template<class T, std::size_t N>
	struct magnitude
	{
		static_assert(std::is_arithmetic<T>(), "first template parameter must be an arithemetic type");

		using vtraits = vector_traits<T, N>;
		
		typename vtraits::scalar_type
		operator()(typename vtraits::param_type v)
		{
			typename vtraits::scalar_type sum = static_cast<typename vtraits::scalar_type>(0);
			for (std::size_t i = 0; i < vtraits::cardinality; ++i)
			{
				sum += v[i] * v[i];
			}
			return static_cast<typename vtraits::scalar_type>( sqrt( static_cast<long double>(sum)));
		}
	};

	template<class T>
	struct magnitude<T, 1>
	{
		static_assert(std::is_arithmetic<T>(), "template parameter must be an arithemetic type");

		using vtraits = vector_traits<T, 1>;
		
		typename vtraits::return_type
		operator()(typename vtraits::param_type v)
		{
			return std::abs(v);
		}
	};
	

	/*! \class cluster
		\brief A cluster generated by the <i>k</i>-means algorithm.
		\tparam T The type of the elements in a data vector. Must
				be an arithmentic type.
		\tparam N The dimensional cardinality of the space containing
				data vectors and clusters.
	
		Instances of this class represent clusters generated by the <i>k</i>-means algorithm.
		
		Applications using k-means should not define specializations of this template or construct instances
		of any tempate class instantiating this template. The \c k_means class template
		will take care of that for you.
		
		\author David Curtis
	*/
	template<class T, std::size_t N>
	class cluster
	{
	public:
		static_assert(std::is_arithmetic<T>(), "first template parameter must be an arithemetic type");

		friend class k_means<T, N>;

		using scalar_type = T;
		using vtraits = vector_traits<T,N>;
		using vector_type = typename vtraits::type;
		using member_set_type = std::set<std::size_t>;
		
		/*! \brief Returns the centroid of the cluster.
			\return A value describing the centroid of the cluster.

			If N (the dimension of the problem space) is greater than one, and the cluster C contains a set of <i>n</i> 
			vectors (that is, instances of \link euclidean_vector euclidean_vector<T,N>\endlink),
			then the centroid \f$ \mathbf{c} \f$ is a vector such that:
			
			\f[ \mathbf{ c } = \frac{1}{n} \sum\limits_{\mathbf{x} \in C} \mathbf{x} \f]
			
			If N = 1, the values in C and the centroid c are scalar (type T) such that:
			
			\f[  c = \frac{1}{n} \sum\limits_{x \in C} x \f]
		 
		*/
		typename vtraits::return_type
		centroid() const
		{
			return centroid_;
		}
		
		/*! \brief Returns the standard deviation of the cluster's members relative to the centroid.
			\return A scalar value (of type T) describing the standard deviation of the cluster's membership.
			
			If N (the dimension of the problem space) is greater than one, and the cluster C with centroid 
			\f$ \mathbf{ c } \f$ contains a set of <i>n</i>
			vectors (that is, instances of \link euclidean_vector euclidean_vector<T,N>\endlink), then the standard deviation
			\f$ \sigma \f$ is:
			
			\f[ \mathbf{ \sigma } = \sqrt{ \frac{1}{n} \sum\limits_{\mathbf{x} \in C} \|\mathbf{x} - \mathbf{ c }\|^2 } \f]

			If N = 1, the members of C and the centroid c are scalar (type T):

			\f[ \mathbf{ \sigma } = \sqrt{ \frac{1}{n} \sum\limits_{x \in C} (x - c)^2 } \f]
			
		*/
		scalar_type
		sigma() const
		{
			return sigma_;
		}
		
		/*! \brief Returns the sum of squared errors of the cluster's members relative to the centroid.
			\return the sum of squared errors of the cluster's membership, as a scalar value of type T.
			
			If N (the dimension of the problem space) is greater than one, and the cluster C with centroid 
			\f$ \mathbf{ c } \f$ contains a set of vectors (that is, instances of \link euclidean_vector 
			euclidean_vector<T,N>\endlink), then the sum of squared errors
			(SSE) is:
			
			\f[ SSE = \sum\limits_{\mathbf{x} \in C} \|\mathbf{x} - \mathbf{ c }\|^2 \f]

			If N = 1, the members of C and the centroid c are scalar (type T):

			\f[ SSE = \sum\limits_{x \in C} (x - c)^2 \f]
			
		*/
		scalar_type
		sse() const
		{
			return sse_;
		}
		
		/*! \brief Returns the variance of the cluster's members relative to the centroid.
			\return the variance of the cluster's membership, as a scalar value of type T.
			
			If N (the dimension of the problem space) is greater than one, and the cluster C with centroid 
			\f$ \mathbf{ c } \f$ contains a set of <i>n</i>
			vectors (that is, instances of \link euclidean_vector euclidean_vector<T,N>\endlink), then the variance
			\f$ \sigma^2 \f$ is:
			
			\f[ \mathbf{ \sigma }^2 =  \frac{1}{n} \sum\limits_{\mathbf{x} \in C} \|\mathbf{x} - \mathbf{ c }\|^2 \f]

			If N = 1, the members of C and the centroid c are scalar (type T):

			\f[ \mathbf{ \sigma }^2 = \frac{1}{n} \sum\limits_{x \in C} (x - c)^2 \f]
			
		*/
		scalar_type
		variance() const
		{
			return variance_;
		}
	
		/*! \brief Returns a set describing cluster membership.
			\return a set of indices (type std::size_t), such that each index identifies an element in 
			the population vector that is a member of this cluster.
			
		*/
		const member_set_type&
		members() const
		{
			return members_;
		}

		cluster(cluster&& rhs)
		:
		population_{rhs.population_},
		members_{std::move(rhs.members_)},
		centroid_{std::move(rhs.centroid_)},
		sigma_{std::move(rhs.sigma_)},
		sse_{rhs.sse_}
		{}

	private:
	
		cluster(const cluster& rhs) = delete;
		cluster() = delete;
		
		cluster(const std::vector<vector_type>& population)
		:
		population_{population}
		{}
	
		void
		add_member(std::size_t index)
		{
			members_.emplace(index);
		}
		
		std::size_t
		size() const
		{
			return members_.size();
		}
		
		void
		calculate_measures()
		{
			centroid_ = 0;
			for (auto i : members_)
			{
				centroid_ += population_[i];
			}
			centroid_ /= static_cast<scalar_type>(members_.size());
		
			sse_ = 0;
			for (auto i : members_)
			{
				scalar_type dist = euclidean_distance<T, N>{}(centroid_, population_[i]);
				sse_ += dist * dist;
			}

			variance_ = sse_ / members_.size();
			sigma_ = static_cast<scalar_type>(sqrt(static_cast<long double>(variance_)));
		}
		
		void
		set_centroid(typename vtraits::param_type p)
		{
			centroid_ = p;
		}

		scalar_type
		gravity(typename vtraits::param_type p) const
		{
			auto dist = euclidean_distance<T, N>{}(centroid_, p);
			std::size_t mass = members_.size();
			return static_cast<scalar_type>(mass) / (dist * dist);
		}
		
		const std::vector<vector_type>& population_;
		std::set<std::size_t> members_;
		vector_type centroid_;
		scalar_type sse_;
		scalar_type variance_;
		scalar_type sigma_;
	};
	
	
	/*! \class k_means
		\brief A class template that partitions a data set into clusters using k-means.
		\tparam T The type of the elements in a data vector. Must
				be an arithmentic type.
		\tparam N The dimensional cardinality of the space containing
				data vectors and clusters.
	
		When an instantiation of this template class is constructed, the data set passed to the constructor
		is partitioned into \a k clusters, where k is also a parameter of the constructor.

		\author David Curtis
	*/
	template<class T, std::size_t N>
	class k_means
	{
	public:

		static_assert(std::is_arithmetic<T>(), "first template parameter must be an arithemetic type");

		using cluster_type = cluster<T, N>;
		using vector_type = typename vector_traits<T,N>::type;
		using cluster_container_type = std::vector<cluster_type>;
		using cluster_set_uptr = std::unique_ptr<cluster_container_type>;
		using scalar_type = typename vector_traits<T,N>::scalar_type;
		using population_type = std::vector<vector_type>;
	
		/*! \brief Constructor
			\param population A container of type \c std::vector<vector_type> containing values that constitute the input data set to be partitioned into clusters.
			\param k the initial number of clusters

			The position (that is, the index) of each element in population serves as its identity. The resulting clusters denote
			their membership as disjoint subsets of the set of indicies of population. Upon construction, the resulting clusters can
			be obtained by calling the members() method, or alternatively, the results() method. Note that the number of clusters
			(that is, the size of the container returned by members()) may not be equal to k; it may be smaller in some circumstances.

			\author David Curtis
		*/
		k_means(const population_type& population, std::size_t k)
		:
		population_{population},
		results_(population.size(), 0),
		previous_clusters_{nullptr},
		current_clusters_{new cluster_container_type},
		sse_{0},
		k_{k}
		{
			for (std::size_t i = 0; i < k; ++i)
			{
				cluster_type c(population);
				current_clusters_->emplace_back(std::move(c));
			}
			
			seed_cluster_centroids();
			
			std::size_t icount = 0;
			bool stable = false;
			do
			{
				partition_clusters();
				
				stable = clusters_stable();
				
				if (!stable)
				{
					#if (TRACE)
					std::cout << "k means iteration " << icount << ", not stable " << std::endl;
					#endif
					
					icount++;
					move_current_to_previous();
				}
				
			} while (!stable);
			
			#if (TRACE)
			std::cout << "k means iteration " << icount << ", stable " << std::endl;
			#endif
			
			calculate_measures();
			copy_current_to_results();
		}

		/*! \brief Attempts to re-assign data elements to clusters based on a gravitational metaphor.
		
			This method may be invoked after the construction of k_means, and may result in improvements in the
			resulting clusters. It operates on the basis of a notional analog of gravity, where the mass of a cluster
			is equal to the number of elements in the cluster, and the 'gravitational force' that a cluster exerts on
			any given element is equal to the mass of the cluster divided by the square of the distance from the centroid
			of the cluster to the element in question. Elements are assigned to the cluster exerting the maximum force on
			the element. After all population members are considered in this manner, if any elements were reassigned to
			different clusters, the cluster centroids are re-calculated and the process is repeated until cluster memberships
			are stable (that is, no elements are re-assigned based on gravity).
			
			Note: this is experimental. It isn't yet clear whether this is a useful concept or not.
		 
			\author David Curtis
		*/
		void
		gravitate()
		{
			bool new_results = false;
			bool something_moved;
			do
			{
				bool something_moved = false;
				
				for (std::size_t iclust = 0; iclust < current_clusters_->size(); ++iclust)
				{
					auto it = (*current_clusters_)[iclust].members_.begin();
					while (it != (*current_clusters_)[iclust].members_.end())
					{
						auto home_gravity = (*current_clusters_)[iclust].gravity(population_[*it]);
						scalar_type max_grav{0};
						std::size_t max_grav_cluster{iclust};
						for (std::size_t jclust = 0; jclust < current_clusters_->size(); ++jclust)
						{
							if (iclust != jclust)
							{
								auto away_gravity = (*current_clusters_)[jclust].gravity(population_[*it]);
								#if (TRACE)
								std::cout << "gravity compare: index " << *it << ", home cluster " << iclust << " gravity is " << home_gravity << ", gravity to cluster " << jclust << " is " << away_gravity << std::endl;
								#endif
								if (away_gravity > home_gravity)
								{
									if (away_gravity > max_grav)
									{
										max_grav = away_gravity;
										max_grav_cluster = jclust;
									}
								}
							}
						}
						if (max_grav_cluster != iclust)
						{
							something_moved = true;
							#if (TRACE)
							std::cout << "gravity moving index " << *it << " from cluster " << iclust << " to cluster " << max_grav_cluster << std::endl;
							#endif
							auto moved_index = *it;
							it = (*current_clusters_)[iclust].members_.erase(it);
							(*current_clusters_)[max_grav_cluster].members_.insert(moved_index);
						}
						else
						{
							++it;
						}
					}
				}
				if (something_moved)
				{
					new_results = true;
					calculate_measures();
				}
			}
			while (something_moved);
			
			if (new_results)
			{
				copy_current_to_results();
			}
		}
		
		
		/*! \brief Returns a container of cluster objects resulting from k-means partitioning of the population
			\return a container of type std::vector<cluster<T,N>>, containing the results of partitioning
		 
			\author David Curtis
		*/
		const cluster_container_type&
		clusters() const
		{
			return *current_clusters_;
		}
		
		/*! \brief Returns a vector of indices describing the results of k-means partitioning of the population.
			\return a map (in the form of a vector of indicies) from elements of the population to clusters of
			which the elements are members.
		 
			The result vector is the same size as the population vector passed to the constructor of k_means.
			Each element in the result vector corresponds to the population element with the same index. The value of the result vector
			at a given index contains the index of the cluster (in the vector of clusters returned by \c clusters()) to which the
			corresponding population element belongs.
			
			\author David Curtis
		*/
		const std::vector<std::size_t>
		result_vector() const
		{
			return results_;
		}
		
		/*! \brief Returns the sum of squared errors of the population.
			\return the sum of squared errors of the population, as a scalar value of type T.
			
			Where there are k clusters C<sub>1</sub> .. C<sub>k</sub> with centroids \f$ \mathbf{ c_1 } .. \mathbf{ c_k } \f$,
			then the population sum of squared errors
			(SSE<sub>pop</sub>) is:
			
			\f[ SSE_{pop} = \sum\limits_{j=1}^{k} \sum\limits_{\mathbf{x} \in C_j} \|\mathbf{x} - \mathbf{ c_j }\|^2 \f]
			
		*/
		scalar_type
		sse() const
		{
			return sse_;
		}
		
	private:
		
		void
		seed_cluster_centroids()
		{
			std::unordered_set<std::size_t> unclustered;
			for (std::size_t i = 0; i < population_.size(); ++i)
			{
				unclustered.insert(i);
			}
			
			auto seed = static_cast<std::default_random_engine::result_type>(std::chrono::system_clock::now().time_since_epoch().count());
			std::default_random_engine gen(seed);
			std::uniform_int_distribution<std::size_t> uniform(0, population_.size() - 1);
			std::size_t pick = uniform(gen);
			
			(*current_clusters_)[0].set_centroid(population_[pick]);
			unclustered.erase(pick);
			
			#if (TRACE)
			std::cout << "initial centroid 0 is index " << pick << " " << population_[pick] << std::endl;
			#endif
			
			for (std::size_t i = 1; i < k_; ++i)
			{
				scalar_type max_dist = 0;
				std::size_t max_dist_index = 0;
				bool first = true;
				for (auto it = unclustered.begin(); it != unclustered.end(); ++it)
				{
					scalar_type dist = 0;
					for (std::size_t j = 0; j < i; ++j)
					{
						dist += euclidean_distance<T,N>{}((*current_clusters_)[j].centroid(), population_[*it]);
					}

					if (first)
					{
						max_dist = dist;
						max_dist_index = *it;
						first = false;
					}
					else
					{
						if (dist > max_dist)
						{
							max_dist = dist;
							max_dist_index = *it;
						}
					}
				}
				(*current_clusters_)[i].set_centroid(population_[max_dist_index]);
				unclustered.erase(max_dist_index);
				
				#if (TRACE)
				std::cout << "initial centroid " << i << " is index " << max_dist_index << std::endl;
				#endif
			}
		}
		
		bool
		clusters_stable()
		{
			bool stable = true;
			
			if (!previous_clusters_)
			{
				stable = false;
			}
			else
			{
				for (std::size_t i = 0; i < current_clusters_->size(); ++i)
				{
					std::vector<std::size_t> diff_out;
					std::set_difference((*current_clusters_)[i].members().cbegin(), (*current_clusters_)[i].members().cend(), (*previous_clusters_)[i].members().cbegin(), (*previous_clusters_)[i].members().cend(), std::back_inserter(diff_out));
					if (!diff_out.empty())
					{
						stable = false;
						break;
					}
				}
			}
			return stable;
		}
		
		void
		partition_clusters()
		{
			std::unordered_set<std::size_t> unclustered;
			for (std::size_t i = 0; i < population_.size(); ++i)
			{
				unclustered.insert(i);
			}
			auto it = unclustered.begin();
			while (it != unclustered.end())
			{
				std::size_t nearest_cluster = 0;
				scalar_type min_dist = 0;
				bool first = true;
				for (std::size_t i = 0; i < current_clusters_->size(); ++i)
				{
					scalar_type dist = euclidean_distance<T,N>{}((*current_clusters_)[i].centroid(), population_[*it]);
					if (first)
					{
						nearest_cluster = i;
						min_dist = dist;
						first = false;
					}
					else
					{
						if (dist < min_dist)
						{
							nearest_cluster = i;
							min_dist = dist;
						}
					}
				}
				(*current_clusters_)[nearest_cluster].add_member(*it);
				it = unclustered.erase(it);
			}
		}
		
		void
		calculate_measures()
		{
			for (std::size_t i = 0; i < current_clusters_->size(); ++i)
			{
				(*current_clusters_)[i].calculate_measures();
			}
			sse_ = calc_sse();
		}
		
		scalar_type calc_sse() const
		{
			scalar_type sum{0};
			for (std::size_t i = 0; i < current_clusters_->size(); ++i)
			{
				sum += (*current_clusters_)[i].sse();
			}
			return sum;
		}
		
		void
		move_current_to_previous()
		{
			previous_clusters_ = cluster_set_uptr(new cluster_container_type);
			auto mv_iter = std::make_move_iterator(current_clusters_->begin());
			auto mv_end_iter = std::make_move_iterator(current_clusters_->end());
			std::size_t i = 0;
			while (mv_iter != mv_end_iter)
			{
				if (mv_iter->size() > 0)
				{
					mv_iter->calculate_measures();
					previous_clusters_->emplace_back(*mv_iter);
				}
				else
				{
					#if (TRACE)
					std::cout << "cluster " << i << " empty, removed" << std::endl;
					#endif
				}
				mv_iter++;
				i++;
			}
			
			current_clusters_ = std::unique_ptr<cluster_container_type>(new cluster_container_type);
			for (std::size_t i = 0; i < previous_clusters_->size(); ++i)
			{
				cluster_type c(population_);
				current_clusters_->emplace_back(std::move(c));
				(*current_clusters_)[i].set_centroid((*previous_clusters_)[i].centroid());
			}
		}
		
		void
		copy_current_to_results()
		{
			for (std::size_t i = 0; i < current_clusters_->size(); ++i)
			{
				for (auto it = (*current_clusters_)[i].members().cbegin(); it != (*current_clusters_)[i].members().cend(); ++it)
				{
					results_[*it] = i;
				}
			}
		}
	
		const population_type& population_;
		std::vector<std::size_t> results_;
		cluster_set_uptr previous_clusters_;
		cluster_set_uptr current_clusters_;
		scalar_type sse_;
		std::size_t k_;
	};
}

#endif // guard_utils_k_means_h
